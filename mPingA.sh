#!/bin/bash
 E='echo -e';e='echo -en';trap "R;exit" 2
 ESC=$( $e "\e")
 TPUT(){ $e "\e[${1};${2}H" ;}
 CLEAR(){ $e "\ec";}
# 25 возможно это
 CIVIS(){ $e "\e[?25l";}
# это цвет текста списка перед курсором при значении 0 в переменной  UNMARK(){ $e "\e[0m";}
 MARK(){ $e "\e[1;90m";}
# 0 это цвет заднего фона списка
 UNMARK(){ $e "\e[0m";}
# ~~~~~~~~ Эти строки задают цвет фона ~~~~~~~~
 R(){ CLEAR ;stty sane;CLEAR;};
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 HEAD(){ for (( a=2; a<=41; a++ ))
  do
   TPUT $a 1
 $E "\033[34m\xE2\x94\x82                                                                                                                 \xE2\x94\x82\033[0m";
  done
 TPUT 1 1
 $E "\033[34m+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+\033[0m"
 TPUT 2 4
 $E "\033[1;36m *** ping - отправить ICMP ECHO_REQUEST на сетевые узлы ***\033[0m                   \033[34m|\033[0m";
 TPUT 14 4
 $E "\033[1;36mОпции                                                                         \033[34m| \033[32mOPTIONS\033[0m";
 TPUT 39 4
 $E "\033[32mUp \xE2\x86\x91 \xE2\x86\x93 Down Select Enter                                                      \033[34m| \033[32m";
 MARK;TPUT 3 1
 $E "\033[34m+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+\033[0m" ;UNMARK;}
  i=0; CLEAR; CIVIS;NULL=/dev/null
 FOOT(){ MARK;TPUT 42 1
 $E "\033[34m+~~~| Grannik | 2021.11.15 |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+\033[0m";UNMARK;}
# это управляет кнопками ввер/хвниз
 i=0; CLEAR; CIVIS;NULL=/dev/null
#
 ARROW(){ IFS= read -s -n1 key 2>/dev/null >&2
           if [[ $key = $ESC ]];then 
              read -s -n1 key 2>/dev/null >&2;
              if [[ $key = \[ ]]; then
                 read -s -n1 key 2>/dev/null >&2;
                 if [[ $key = A ]]; then echo up;fi
                 if [[ $key = B ]];then echo dn;fi
              fi
           fi
           if [[ "$key" == "$($e \\x0A)" ]];then echo enter;fi;}
 M0(){ TPUT  4 3; $e "Обзор                                                                          \033[32m SYNOPSIS                      \033[0m";}
 M1(){ TPUT  5 3; $e "Описание                                                                       \033[32m DESCRIPTION                   \033[0m";}
 M2(){ TPUT  6 3; $e "Детали пакета ICMP                                                             \033[32m ICMP PACKET DETAILS           \033[0m";}
 M3(){ TPUT  7 3; $e "Ошибки                                                                         \033[32m BUGS                          \033[0m";}
 M4(){ TPUT  8 3; $e "Дупликационные и поврежденные пакеты                                           \033[32m DUPLICATE AND DAMAGED PACKETS \033[0m";}
 M5(){ TPUT  9 3; $e "Испытание разных образцов данных                                               \033[32m TRYING DIFFERENT DATA PATTERNS\033[0m";}
 M6(){ TPUT 10 3; $e "Детели TTL                                                                     \033[32m TTL DETAILS                   \033[0m";}
 M7(){ TPUT 11 3; $e "Смотрите также                                                                 \033[32m SEE ALSO                      \033[0m";}
 M8(){ TPUT 12 3; $e "История                                                                        \033[32m HISTORY                       \033[0m";}
 M9(){ TPUT 13 3; $e "Доступность                                                                    \033[32m AVAILABILITY                  \033[0m";}
#
M10(){ TPUT 15 3; $e "Используйте только IPv4                                                        \033[32m -4                            \033[0m";}
M11(){ TPUT 16 3; $e "Используйте только IPv6                                                        \033[32m -6                            \033[0m";}
M12(){ TPUT 17 3; $e "Слышен пинг                                                                    \033[32m -a                            \033[0m";}
M13(){ TPUT 18 3; $e "Адаптивный пинг                                                                \033[32m -A                            \033[0m";}
M14(){ TPUT 19 3; $e "Разрешить пинговать широковещательный адрес                                    \033[32m -b                            \033[0m";}
M15(){ TPUT 20 3; $e "Не позволяйте ping изменять исходный адрес зондов                              \033[32m -B                            \033[0m";}
M16(){ TPUT 21 3; $e "Остановить после отправки количества пакетов ECHO_REQUEST                      \033[32m -c count                      \033[0m";}
M17(){ TPUT 22 3; $e "Установите опцию SO_DEBUG для используемого сокета                             \033[32m -d                            \033[0m";}
M18(){ TPUT 23 3; $e "Печатать временную метку                                                       \033[32m -D                            \033[0m";}
M19(){ TPUT 24 3; $e "Флуд пинг                                                                      \033[32m -f                            \033[0m";}
M20(){ TPUT 25 3; $e "Только IPv6                                                                    \033[32m -F flow label                 \033[0m";}
M21(){ TPUT 26 3; $e "Покажи справку                                                                 \033[32m -h                            \033[0m";}
M22(){ TPUT 27 3; $e "Интервал ожидания в секундах между отправкой каждого пакета                    \033[32m -i interval                   \033[0m";}
M23(){ TPUT 28 3; $e "interface - это адрес, имя интерфейса или имя VRF                              \033[32m -I interface                  \033[0m";}
M24(){ TPUT 29 3; $e "Если указана предварительная загрузка, ping отправляет такое количество пакетов\033[32m -l preload                    \033[0m";}
M25(){ TPUT 30 3; $e "Подавление обратной петли для многоадресных пакетов                            \033[32m -L                            \033[0m";}
M26(){ TPUT 31 3; $e "Используйте метку, чтобы пометить исходящие пакеты                             \033[32m -m mark                       \033[0m";}
M27(){ TPUT 32 3; $e "Выберите стратегию обнаружения MTU пути                                        \033[32m -M pmtudisc_opt               \033[0m";}
M28(){ TPUT 33 3; $e "Только IPv6. Отправляйте запросы информации об узлах ICMPv6 (RFC4620)          \033[32m -N nodeinfo_option            \033[0m";}
M29(){ TPUT 34 3; $e "Показать справку по поддержке NI                                               \033[32m    help                       \033[0m";}
M30(){ TPUT 35 3; $e "Запросы имен узлов                                                             \033[32m    name                       \033[0m";}
M31(){ TPUT 36 3; $e "Запросы адресов IPv6                                                           \033[32m    ipv6                       \033[0m";}
M32(){ TPUT 37 3; $e "Запросить IPv6-адреса в глобальной области                                     \033[32m    ipv6-global                \033[0m";}
M33(){ TPUT 38 3; $e "Запросите локальные адреса сайта IPv6                                          \033[32m ipv6-sitelocal                \033[0m";}
#
M34(){ TPUT 40 3; $e "Далее                                                                          \033[32m Onward                         \033[0m";}
M35(){ TPUT 41 3; $e "Выход                                                                          \033[32m EXIT                           \033[0m";}
LM=35
   MENU(){ for each in $(seq 0 $LM);do M${each};done;}
    POS(){ if [[ $cur == up ]];then ((i--));fi
           if [[ $cur == dn ]];then ((i++));fi
           if [[ $i -lt 0   ]];then i=$LM;fi
           if [[ $i -gt $LM ]];then i=0;fi;}
REFRESH(){ after=$((i+1)); before=$((i-1))
           if [[ $before -lt 0  ]];then before=$LM;fi
           if [[ $after -gt $LM ]];then after=0;fi
           if [[ $j -lt $i      ]];then UNMARK;M$before;else UNMARK;M$after;fi
           if [[ $after -eq 0 ]] || [ $before -eq $LM ];then
           UNMARK; M$before; M$after;fi;j=$i;UNMARK;M$before;M$after;}
   INIT(){ R;HEAD;FOOT;MENU;}
     SC(){ REFRESH;MARK;$S;$b;cur=`ARROW`;}
# Функция возвращения в меню
     ES(){ MARK;$e " ENTER = main menu ";$b;read;INIT;};INIT
  while [[ "$O" != " " ]]; do case $i in
 0) S=M0;SC;if [[ $cur == enter ]];then R;echo " ping [-aAbBdDfhLnOqrRUvV46] [-c count] [-F flowlabel] [-i interval] [-I interface] [-l preload] [-m mark] [-M pmtudisc_option] [-N nodeinfo_option] [-w deadline]
 [-W timeout] [-p pattern] [-Q tos] [-s packetsize] [-S sndbuf] [-t ttl] [-T timestamp option] [hop...] {destination}";ES;fi;;
 1) S=M1;SC;if [[ $cur == enter ]];then R;echo " ping использует обязательную дейтаграмму ECHO_REQUEST протокола ICMP, чтобы вызвать ICMP ECHO_RESPONSE от хоста или шлюза. Дейтаграммы ECHO_REQUEST («пинги») имеют
 заголовок IP и ICMP, за которым следует структура timeval, а затем произвольное количество «Pad» байты, используемые для заполнения пакета. ping работает как
 с IPv4, так и с IPv6. Явное использование только одного из них можно принудительно применить, указав -4 или -6. ping также может отправлять запросы информации об
 узлах IPv6 (RFC4620). Промежуточные переходы могут быть запрещены, поскольку источник IPv6 маршрутизация устарела (RFC5095).";ES;fi;;
 2) S=M2;SC;if [[ $cur == enter ]];then R;echo "   Заголовок IP без параметров составляет 20 байтов. Пакет ICMP ECHO_REQUEST содержит дополнительные 8 байтов заголовка ICMP за которым следует произвольный объем
 данных. Когда указан размер пакета, это указывает размер этой дополнительной части данных (по умолчанию 56). Таким образом, количество данных, полученных внутри
 IP-пакета типа ICMP ECHO_REPLY, всегда будет 8 байтов больше запрошенного пространства данных (заголовок ICMP). Если размер пространства данных не меньше размера
 struct timeval, ping использует начальные байты этого пространства для включения отметки времени который он использует при вычислении времени прохождения туда и
 обратно. Если пространство данных короче, время приема-передачи не указывается.";ES;fi;;
 3) S=M3;SC;if [[ $cur == enter ]];then R;echo " • Многие хосты и шлюзы игнорируют параметр RECORD_ROUTE.
 • Максимальная длина IP-заголовка слишком мала для использования таких параметров, как RECORD_ROUTE. Не так много oднако это можно сделать с этим.
 • Флуд-пинг в целом не рекомендуется, а флуд-пинг по широковещательному адресу должен выполняться только в очень контролируемые условия.";ES;fi;;
 4) S=M4;SC;if [[ $cur == enter ]];then R;echo "   ping сообщит о повторяющихся и поврежденных пакетах. Дублирующиеся пакеты никогда не должны возникать и, похоже, вызваны недопустимые повторные передачи на уровне
 ссылок. Дубликаты могут встречаться во многих ситуациях и редко (если вообще когда-либо) являются хорошим признаком хотя наличие небольшого количества дубликатов не
 всегда может быть поводом для беспокойства. Поврежденные пакеты, очевидно, являются серьезной причиной для тревоги и часто указывают на сломанное оборудование где-то
 в ping-пакете путь (в сети или в хостах).";ES;fi;;
 5) S=M5;SC;if [[ $cur == enter ]];then R;echo "   (Меж) сетевой уровень никогда не должен обрабатывать пакеты по-разному в зависимости от данных, содержащихся в части данных. К сожалению, проблемы, зависящие от
 данных, проникают в сети и остаются незамеченными в течение долгих периодов времени время. Во многих случаях конкретный шаблон, который вызывает проблемы, - это то,
 что не имеет достаточных «переходов», например, все единицы или все нули, или узор прямо на краю, например, почти все нули. Не обязательно укажите шаблон данных из
 всех нулей (например) в командной строке, потому что интересующий шаблон находится в уровень передачи данных и взаимосвязь между тем, что вы вводите, и тем, что
 передают контроллеры, могут быть сложными. Это означает, что если у вас есть проблема, связанная с данными, вам, вероятно, придется провести много тестов, чтобы
 найти ее. Если ты повезло, возможно, вам удастся найти файл, который либо не может быть отправлен по вашей сети, либо для передачи которого требуется гораздо больше
 времени чем другие файлы аналогичной длины. Затем вы можете проверить этот файл на наличие повторяющихся шаблонов, которые вы можете протестировать с помощью
 параметра -p. пинга.";ES;fi;;
 6) S=M6;SC;if [[ $cur == enter ]];then R;echo "   Значение TTL IP-пакета представляет максимальное количество IP-маршрутизаторов, через которое может пройти пакет, прежде чем он будет выброшенный. В текущей
 практике вы можете ожидать, что каждый маршрутизатор в Интернете будет уменьшать поле TTL ровно на единицу.
   В спецификации TCP / IP указано, что поле TTL для пакетов TCP должно быть установлено на 60, но многие системы используют меньшие значения. (4.3 BSD использует
 30, 4.2 используется 15). Максимально возможное значение этого поля - 255, и большинство систем Unix устанавливают поле TTL пакетов ICMP ECHO_REQUEST равным 255.
 Вот почему вы обнаружите, что можете «пинговать» некоторые хосты, но не можете связаться с ними с помощью telnet или ftp. В нормальном режиме ping печатает значение
 TTL из полученного пакета. Когда удаленная система получает пакет ping, она может выполнять одно из трех действий с полем TTL в своем ответе:
 • Не менять; это то, что делали системы Berkeley Unix до выпуска 4.3BSD Tahoe. В этом случае значение TTL в полученный пакет будет 255 минус количество
 маршрутизаторов в пути приема-передачи.
 • Установите 255; это то, что делают современные системы Berkeley Unix. В этом случае значение TTL в полученном пакете будет быть 255 минус количество
 маршрутизаторов на пути от удаленной системы к хосту для проверки связи.
 • Установите другое значение. Некоторые машины используют то же значение для пакетов ICMP, что и для пакетов TCP, для например, 30 или 60. Другие могут использовать
 полностью дикие значения.";ES;fi;;
 7) S=M7;SC;if [[ $cur == enter ]];then R;echo " ip(8), ss(8).";ES;fi;;
 8) S=M8;SC;if [[ $cur == enter ]];then R;echo "   Команда ping появилась в 4.3BSD. Описанная здесь версия является ее потомком, специфичным для Linux. Начиная с версии s20150815 двоичный файл ping6 больше не
 существует. Он был объединен в ping. Создание символической ссылки с именем ping6, указывающий на ping, приведет к той же функциональности, что и раньше.";ES;fi;;
 9) S=M9;SC;if [[ $cur == enter ]];then R;echo " ping является частью пакета iputils.";ES;fi;;
10) S=M10;SC;if [[ $cur == enter ]];then R;echo " Используйте только IPv4.";ES;fi;;
11) S=M11;SC;if [[ $cur == enter ]];then R;echo " Используйте только IPv6.";ES;fi;;
12) S=M12;SC;if [[ $cur == enter ]];then R;echo " Слышен пинг.";ES;fi;;
13) S=M13;SC;if [[ $cur == enter ]];then R;echo "   Адаптивный пинг. Межпакетный интервал адаптируется ко времени приема-передачи, так что эффективно не более одного (или более, если установлена предварительная
 нагрузка) в сети присутствует неотвеченный зонд. Минимальный интервал составляет 200 мсек, если не является суперпользователем. В сетях с низким RTT этот режим по
 сути эквивалентен режиму лавинной рассылки.";ES;fi;;
14) S=M14;SC;if [[ $cur == enter ]];then R;echo " Разрешить пинговать широковещательный адрес.";ES;fi;;
15) S=M15;SC;if [[ $cur == enter ]];then R;echo " Не позволяйте ping изменять исходный адрес зондов. Адрес привязывается к одному, выбранному при запуске пинга.";ES;fi;;
16) S=M16;SC;if [[ $cur == enter ]];then R;echo " Остановить после отправки количества пакетов ECHO_REQUEST. С опцией крайнего срока ping ожидает количества пакетов ECHO_REPLY, пока таймаут истекает.";ES;fi;;
17) S=M17;SC;if [[ $cur == enter ]];then R;echo " Установите опцию SO_DEBUG для используемого сокета. По сути, этот параметр сокета не используется ядром Linux.";ES;fi;;
18) S=M18;SC;if [[ $cur == enter ]];then R;echo " Печатать временную метку (время unix + микросекунды, как в gettimeofday) перед каждой строкой.";ES;fi;;
19) S=M19;SC;if [[ $cur == enter ]];then R;echo "   Флуд пинг. Для каждого отправленного ECHO_REQUEST периода \".\" печатается, в то время как для каждого полученного ECHO_REPLY возвращается напечатаны. Это
 обеспечивает быстрое отображение количества отброшенных пакетов. Если интервал не указан, он устанавливает интервал равен нулю и выводит пакеты с такой же
 скоростью, как они возвращаются, или сто раз в секунду, в зависимости от того, что больше. Только суперпользователь может использовать эту опцию с нулевым
 интервалом.";ES;fi;;
20) S=M20;SC;if [[ $cur == enter ]];then R;echo "   Только IPv6. Выделяет и устанавливает 20-битную метку потока (в шестнадцатеричном формате) для пакетов эхо-запроса. Если значение равно нулю, ядро выделяет метка
 случайного потока.";ES;fi;;
21) S=M21;SC;if [[ $cur == enter ]];then R;echo " Покажи справку.";ES;fi;;
22) S=M22;SC;if [[ $cur == enter ]];then R;echo "   Интервал ожидания в секундах между отправкой каждого пакета. Допускается вещественное число с точкой в качестве десятичного разделителя (независимо от настройка
 локали). По умолчанию обычно следует ждать одну секунду между каждым пакетом или не ждать в режиме лавинной рассылки. Только суперпользователь может установить
 интервал менее 0,2 секунды.";ES;fi;;
23) S=M23;SC;if [[ $cur == enter ]];then R;echo "  interface - это адрес, имя интерфейса или имя VRF. Если интерфейс является адресом, он устанавливает адрес источника как указанный адрес интерфейса. Если interface
 - это имя интерфейса, он устанавливает исходный интерфейс для указанного интерфейса. Если interface - имя VRF, каждый пакет маршрутизируется с использованием
 соответствующей таблицы маршрутизации; в этом случае опция -I может повторяется, чтобы указать адрес источника. ПРИМЕЧАНИЕ. Для IPv6 при выполнении эхо-запроса на
 адрес локальной области связи ссылка спецификация (обозначением «%» в пункте назначения или этой опцией) может использоваться, но больше не требуется.";ES;fi;;
24) S=M24;SC;if [[ $cur == enter ]];then R;echo "  Если указана предварительная загрузка, ping отправляет такое количество пакетов, не ожидая ответа. Только суперпользователь может выбрать предварительную загрузку
 более 3-х.";ES;fi;;
25) S=M25;SC;if [[ $cur == enter ]];then R;echo "  Подавление обратной петли для многоадресных пакетов.
 Этот флаг применяется только в том случае, если пункт назначения ping является адресом многоадресной рассылки.";ES;fi;;
26) S=M26;SC;if [[ $cur == enter ]];then R;echo " используйте метку, чтобы пометить исходящие пакеты. Это полезно по разным причинам внутри ядра, например, при использовании политики маршрутизация для выбора
 конкретной исходящей обработки.";ES;fi;;
27) S=M27;SC;if [[ $cur == enter ]];then R;echo "  Выберите стратегию обнаружения MTU пути. pmtudisc_option может быть либо do (запретить фрагментацию, даже локальную), хотеть (выполнить обнаружение PMTU,
 фрагментировать локально при большом размере пакета) или не делать (не устанавливать флаг DF).";ES;fi;;
28) S=M28;SC;if [[ $cur == enter ]];then R;echo " Только IPv6. Отправляйте запросы информации об узлах ICMPv6 (RFC4620) вместо эхо-запроса. Требуется возможность CAP_NET_RAW.";ES;fi;;
29) S=M29;SC;if [[ $cur == enter ]];then R;echo " Показать справку по поддержке NI.";ES;fi;;
30) S=M30;SC;if [[ $cur == enter ]];then R;echo " Запросы имен узлов.";ES;fi;;
31) S=M31;SC;if [[ $cur == enter ]];then R;echo " Запросы адресов IPv6. Есть несколько специфичных для IPv6 флагов.";ES;fi;;
32) S=M32;SC;if [[ $cur == enter ]];then R;echo " Запросить IPv6-адреса в глобальной области.";ES;fi;;
33) S=M33;SC;if [[ $cur == enter ]];then R;echo " Запросите локальные адреса сайта IPv6.";ES;fi;;
#
34) S=M34;SC;if [[ $cur == enter ]];then R;./mPingB.sh;ES;fi;;
35) S=M35;SC;if [[ $cur == enter ]];then R;clear;ls -l;exit 0;fi;;
 esac;POS;done
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Маленькая программка туториал (пошаговое объяснение, инструкция по выполнению) Утилита ping - отправить ICMP ECHO_REQUEST на сетевые узлы.
